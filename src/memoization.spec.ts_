import { table } from 'table'
import { makeTreeNodes, TREE_1 } from '../test/trees'
import { callCounter } from '../test/util'

import * as treeStructure from './structure'
import * as treeTraversal from './traversal'

import { treeMemo } from './memoization'

const onlyFunctions = obj => Object.keys(obj).reduce((result, key) => (
  typeof obj[key] === 'function'
    ? { ...result, [key]: obj[key] }
    : result
), {})

const NON_MEMO = {
  ...onlyFunctions(treeStructure),
  ...onlyFunctions(treeTraversal)
}

const runNTimes = (fn, n) => {
  while (n > 0) {
    fn()

    n--
  }
}

const naiveBenchmark = (fn, runs = 10000) => {
  const start = performance.now()

  const result = fn()

  runNTimes(fn, runs - 1)

  const end = performance.now()

  return {
    result,
    timeElapsed: end - start
  }
}

const treeNodes = makeTreeNodes([
  'root',
  'root_0',
  'root_0_0',
  'root_0_0_0',
  'root_0_0_1',
  'root_0_0_1_0',
  'root_0_0_1_1',
  'root_0_0_1_2',
  'root_0_0_1_2_0',
  'root_0_0_1_2_0_0',
  'root_0_0_1_2_0_0',
  'root_0_0_1_2_0_1',
  'root_0_0_1_2_0_1_0',
  'root_0_0_1_2_0_1_0_0',
  'root_0_0_1_2_0_1_0_0_0',
  'root_0_0_1_2_0_1_0_0_0_0',
  'root_0_0_1_2_0_1_0_0_0_1',
  'root_0_0_1_2_0_1_0_0_0_1_0',
  'root_0_0_1_2_0_2',
  'root_0_0_1_2_1',
  'root_0_0_1_2_2',
  'root_0_0_2',
  'root_0_1',
  'root_0_1_0',
  'root_0_1_1',
  'root_0_1_2',
  'root_1',
  'root_1_0',
  'root_1_1',
  'root_1_1_0',
  'root_1_1_0_0',
  'root_1_1_0_1',
  'root_1_1_0_1_0',
  'root_1_1_0_1_1',
  'root_1_1_0_1_1_0',
  'root_1_1_0_1_1_1',
  'root_1_1_0_1_1_1_0',
  'root_1_1_0_1_1_1_1',
  'root_1_1_0_2',
  'root_1_1_1',
  'root_1_1_2',
  'root_1_2',
  'root_2',
  'root_2_0',
  'root_2_0_0',
  'root_2_0_0_0',

  'root_3',
  'root_3_0',
  'root_3_0_0',
  'root_3_0_1',
  'root_3_0_1_0',
  'root_3_0_1_1',
  'root_3_0_1_2',
  'root_3_0_1_2_0',
  'root_3_0_1_2_0_0',
  'root_3_0_1_2_0_0',
  'root_3_0_1_2_0_1',
  'root_3_0_1_2_0_1_0',
  'root_3_0_1_2_0_1_0_0',
  'root_3_0_1_2_0_1_0_0_0',
  'root_3_0_1_2_0_1_0_0_0_0',
  'root_3_0_1_2_0_1_0_0_0_1',
  'root_3_0_1_2_0_1_0_0_0_1_0',
  'root_3_0_1_2_0_2',
  'root_3_0_1_2_1',
  'root_3_0_1_2_2',
  'root_3_0_2',
  'root_3_1',
  'root_3_1_0',
  'root_3_1_1',
  'root_3_1_2',
  'root_4',
  'root_4_0',
  'root_4_1',
  'root_4_1_0',
  'root_4_1_0_0',
  'root_4_1_0_1',
  'root_4_1_0_1_0',
  'root_4_1_0_1_1',
  'root_4_1_0_1_1_0',
  'root_4_1_0_1_1_1',
  'root_4_1_0_1_1_1_0',
  'root_4_1_0_1_1_1_1',
  'root_4_1_0_2',
  'root_4_1_1',
  'root_4_1_2',
  'root_4_2',
  'root_5',
  'root_5_0',
  'root_5_0_0',
  'root_5_0_0_0',
])

const RESULTS = []

const memoCompare = (fn, args, {
  timeRatio = null,
  id = null,
  pre = null,
  runs = 1000
} = {}) => {
  const memo = treeMemo()
  const memoFn = typeof fn === 'string'
    ? memo[fn]
    : fn[0]
  const nonMemoFn = typeof fn === 'string'
    ? NON_MEMO[fn]
    : fn[1]

  const runMemoFn = () => memoFn(...args)
  const runNonMemoFn = () => nonMemoFn(...args)

  pre = typeof pre === 'function'
    ? pre
    : () => {
      runMemoFn()
      runNonMemoFn()
    }

  pre()

  const memoResult = naiveBenchmark(runMemoFn, runs)
  const nonMemoResult = naiveBenchmark(runNonMemoFn, runs)

  RESULTS.push([
    id,
    timeRatio,
    memoResult.timeElapsed,
    nonMemoResult.timeElapsed
  ])

  expect(memoResult.result).toEqual(nonMemoResult.result)

  if (timeRatio !== null) {
    expect(memoResult.timeElapsed / nonMemoResult.timeElapsed).toBeLessThan(timeRatio)
  }

  return [memoResult, nonMemoResult]
}

describe('treeMemo(selectors)', () => {
  afterAll(() => {
    console.log(table([
      ['id', 'ratio', 'memo', 'non-memo'],
      ...RESULTS.map(([id, expectedRatio, memo, nonMemo]) => {
        const ratio = (memo / nonMemo).toFixed(4)
        return [
          id,
          expectedRatio
            ? `${ratio} (expected < ${expectedRatio.toFixed(4)})`
            : ratio,
          memo.toFixed(4),
          nonMemo.toFixed(4)
        ]
      })
    ]))
  })

  test('treeNodeArray', () => {
    memoCompare('treeNodeArray', [treeNodes], {
      id: 'treeNodeArray(treeNodes)',
      timeRatio: 1
    })
  })

  describe('treeNodeTree', () => {
    test('root', () => {
      memoCompare('treeNodeTree', [treeNodes, 'root'], {
        id: 'treeNodeTree(treeNodes, "root")',
        timeRatio: 0.05
      })
    })

    test('root_1', () => {
      memoCompare('treeNodeTree', [treeNodes, 'root_1'], {
        id: 'treeNodeTree(treeNodes, "root_1")',
        timeRatio: 0.1
      })
    })
  })

  describe('treeNodeIsRoot', () => {
    test('root', () => {
      memoCompare('treeNodeIsRoot', [treeNodes, 'root'], {
        id: 'treeNodeIsRoot(treeNodes, "root")'
      })
    })
  })

  describe('treeRootNodeId', () => {
    test('', () => {
      memoCompare('treeRootNodeId', [treeNodes], {
        id: 'treeRootNodeId(treeNodes)',
        timeRatio: 1
      })
    })
  })

  describe('treeNodeAncestorIds', () => {
    test('', () => {
      memoCompare('treeNodeAncestorIds', [treeNodes, 'root_0_0_1_2_0_1_0_0_0_1_0'], {
        id: 'treeNodeAncestorIds(treeNodes, "root_0_0_1_2_0_1_0_0_0_1_0")',
        timeRatio: 0.3
      })
    })
  })

  describe('treeNodePath', () => {
    test('', () => {
      memoCompare('treeNodePath', [treeNodes, 'root_0_0_1_2_0_1_0_0_0_1_0'], {
        id: 'treeNodePath(treeNodes, "root_0_0_1_2_0_1_0_0_0_1_0")',
        timeRatio: 0.3
      })
    })
  })

  describe('treeNodeIsAncestorOf', () => {
    test('', () => {
      memoCompare(
        'treeNodeIsAncestorOf',
        [treeNodes, 'root_0', 'root_0_0_1_2_0_1_0_0_0_1_0'],
        {
          id: 'treeNodeIsAncestorOf(treeNodes, "root_0", "root_0_0_1_2_0_1_0_0_0_1_0")',
          timeRatio: 0.5
        }
      )
    })
  })

  describe('treeNodeIsDescendantOf', () => {
    test('', () => {
      memoCompare(
        'treeNodeIsDescendantOf',
        [treeNodes, 'root_0_0_1_2_0_1_0_0_0_1_0', 'root_0'],
        {
          id: 'treeNodeIsDescendantOf(treeNodes, "root_0_0_1_2_0_1_0_0_0_1_0", "root_0")',
          timeRatio: 0.5
        }
      )
    })
  })

  describe('treeNodeChildNodeIds', () => {
    test('', () => {
      memoCompare(
        'treeNodeChildNodeIds',
        [treeNodes, 'root'],
        {
          id: 'treeNodeChildNodeIds(treeNodes, "root")',
          timeRatio: 0.5
        }
      )
    })
  })

  describe('treeNodeSiblingIds', () => {
    test('', () => {
      memoCompare(
        'treeNodeSiblingIds',
        [treeNodes, 'root_1'],
        {
          id: 'treeNodeSiblingIds(treeNodes, "root_1")',
          timeRatio: 0.5
        }
      )
    })
  })

  describe('treeNodeIsSiblingOf', () => {
    test('', () => {
      memoCompare(
        'treeNodeIsSiblingOf',
        [treeNodes, 'root_1', 'root_2'],
        {
          id: 'treeNodeIsSiblingOf(treeNodes, "root_1", "root_2")'
        }
      )
    })
  })

  describe('custom fn', () => {
    test('', () => {

      const customQuery1 = (nodesById, nodeId) => treeTraversal.treeNodeAncestorIds(
        nodesById,
        nodeId
      ).reverse()

      const { memoCustomQuery } = treeMemo({
        memoCustomQuery: [
          ['treeNodeAncestorIds'],
          treeNodeAncestorIds => (nodesById, nodeId) => customQuery1(nodesById, nodeId)
        ]
      })

      memoCompare(
        [memoCustomQuery, customQuery1],
        [treeNodes, 'root_0_0_1_2_0_1_0_0_0_1_0'],
        {
          id: 'customQuery1(treeNodes, "root_0_0_1_2_0_1_0_0_0_1_0")',
          timeRatio: 0.5
        }
      )
    })
  })
})
