import toposort from 'toposort'

import {
  treeNodesById,
  treeNodeIdArray,
  treeNodeArray,
  treeNodeTree,
} from './structure'

import {
  treeNodeIsRoot,
  treeRootNodeId,
  treeNodeAncestorIds,
  treeNodePath,
  treeNodeIsAncestorOf,
  treeNodeIsDescendantOf,
  treeNodeChildNodeIds,
  treeNodeSiblingIds,
  treeNodeIsSiblingOf,
  treeNodesCommonPath,
  treeNodesCommonAncestorPath
} from './traversal'

import { stateQueryCache } from '@orioro/state-query-cache'

import { dependencyTreeResolve } from '@orioro/dependency-tree'

const MEMO_DEPENDENCY_SPECS = {
  treeNodesById: stateQueryCache(treeNodesById, 0),
  treeNodeIdArray: stateQueryCache(treeNodeIdArray, 0),
  treeNodeArray: [
    ['treeNodeIdArray'],
    (treeNodeIdArray) => nodesById => treeNodeArray(
      nodesById,
      treeNodeIdArray
    ),
    0
  ],
  treeNodeTree: [
    ['treeNodeArray'],
    (treeNodeArray) => {
      const memoTreeNodeTree = (nodesById, nodeId) => treeNodeTree(
        nodesById,
        nodeId,
        treeNodeArray,
        memoTreeNodeTree
      )

      return memoTreeNodeTree
    },
    1
  ],
  treeNodeIsRoot,
  treeRootNodeId: [
    ['treeNodeIdArray'],
    treeNodeIdArray => nodesById => treeRootNodeId(
      nodesById,
      treeNodeIdArray
    ),
    0
  ],
  treeNodeAncestorIds: [
    [],
    () => {
      const memoTreeNodeAncestorIds = (nodesById, nodeId) => treeNodeAncestorIds(
        nodesById,
        nodeId,
        memoTreeNodeAncestorIds
      )

      return memoTreeNodeAncestorIds
    },
    1
  ],
  treeNodePath: [
    ['treeNodeAncestorIds'],
    treeNodeAncestorIds => (nodesById, nodeId) => treeNodePath(
      nodesById,
      nodeId,
      treeNodeAncestorIds
    ),
    1
  ],
  treeNodeIsAncestorOf: [
    ['treeNodeAncestorIds'],
    treeNodeAncestorIds => (nodesById, ancestor, descendant) => treeNodeIsAncestorOf(
      nodesById,
      ancestor,
      descendant,
      treeNodeAncestorIds
    ),
    2
  ],
  treeNodeIsDescendantOf: [
    ['treeNodeAncestorIds'],
    treeNodeAncestorIds => (nodesById, descendant, ancestor) => treeNodeIsDescendantOf(
      nodesById,
      descendant,
      ancestor,
      treeNodeAncestorIds
    ),
    2
  ],
  treeNodeChildNodeIds: [
    ['treeNodeIdArray'],
    treeNodeIdArray => (nodesById, nodeId) => treeNodeChildNodeIds(
      nodesById,
      nodeId,
      treeNodeIdArray
    ),
    1
  ],
  treeNodeSiblingIds: [
    ['treeNodeIdArray'],
    treeNodeIdArray => (nodesById, nodeId) => treeNodeSiblingIds(
      nodesById,
      nodeId,
      treeNodeIdArray
    ),
    1
  ],
  treeNodeIsSiblingOf,
  treeNodesCommonPath,
  treeNodesCommonAncestorPath
}

export const treeMemo = (selectors = {}) => {
  const specs = {
    ...MEMO_DEPENDENCY_SPECS,
    ...selectors
  }

  return dependencyTreeResolve(Object.keys(specs).reduce((res, id) => {
    const spec = specs[id]

    if (Array.isArray(spec)) {
      const [dependencies, queryCreator, queryArgumentCount] = spec

      return {
        ...res,
        [id]: [
          dependencies,
          (...deps) => stateQueryCache(
            queryCreator(...deps),
            queryArgumentCount
          )
        ]
      }
    } else {
      return { ...res, [id]: spec }
    }
  }, {}))
}
